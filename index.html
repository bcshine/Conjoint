<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>콘조인트 분석 프로그램</title>
    <!-- Chart.js 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <style>
        :root {
            --primary-color: #4c6ef5;
            --secondary-color: #f8f9fa;
            --border-color: #dee2e6;
            --text-color: #212529;
            --success-color: #38b2ac;
            
            /* Modern, elegant color palette */
            --chart-color-1: #5B7FFF; /* Soft blue */
            --chart-color-2: #36D1DC; /* Turquoise */
            --chart-color-3: #5C54A4; /* Medium purple */
            --chart-color-4: #FF7676; /* Coral pink */
            --chart-color-5: #4CB58E; /* Mint green */
        }
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h1, h2, h3 {
            color: var(--primary-color);
            margin-top: 0;
        }
        
        input, select, button {
            font-family: inherit;
            font-size: 16px;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            border: none;
            padding: 10px 15px;
            margin: 10px 0;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #364fc7;
        }
        
        .step {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: white;
        }
        
        .step h2 {
            margin-top: 0;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .attribute-container, .product-container {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 8px;
        }
        
        .level-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .level-container input {
            margin-right: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: var(--primary-color);
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: var(--secondary-color);
        }
        
        .results {
            display: none;
            margin-top: 30px;
        }
        
        .error {
            color: #e53e3e;
            margin: 5px 0;
        }
        
        .success {
            color: var(--success-color);
            margin: 5px 0;
        }
        
        .hide {
            display: none;
        }
        
        .btn-secondary {
            background-color: #6c757d;
        }
        
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        
        .btn-reset {
            background-color: #e53e3e;
        }
        
        .btn-reset:hover {
            background-color: #c53030;
        }
        
        .highlight {
            background-color: rgba(76, 110, 245, 0.1);
            padding: 2px;
        }
        
        /* 막대 그래프 및 차트 스타일 */
        .chart-container {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 8px;
        }
        
        .pie-chart-container {
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
            height: 300px;
            position: relative;
        }
        
        .charts-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-between;
        }
        
        .chart-column {
            flex: 1;
            min-width: 300px;
        }
        
        .simulation-container {
            margin: 20px 0;
            padding: 20px;
            background-color: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .simulation-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .slider-container {
            flex: 1;
            min-width: 250px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .simulation-slider {
            width: 100%;
        }
        
        .chart-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
        }
        
        .bar-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .bar-label {
            width: 120px;
            font-weight: bold;
            margin-right: 10px;
            text-align: right;
        }
        
        .bar-wrapper {
            flex-grow: 1;
            position: relative;
            height: 30px;
            background-color: #fff;
            border-radius: 0;
        }
        
        .bar {
            height: 100%;
            border-radius: 0;
            transition: width 0.8s ease;
            position: relative;
        }
        
        .bar-value {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: #fff;
            padding: 0 8px;
        }
        
        .bar-positive {
            background-color: var(--chart-color-2);
        }
        
        .bar-negative {
            background-color: var(--chart-color-4);
        }
        
        .bar-chart-grid {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 0;
        }
        
        .grid-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background-color: #ddd;
            z-index: 0;
        }
        
        .bar-chart-x-axis {
            position: relative;
            height: 20px;
            margin-top: 5px;
            margin-left: 130px;
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
        }
        
        .product-chart {
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .step {
                padding: 15px;
            }
            
            .bar-label {
                width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>콘조인트 분석 프로그램</h1>
        <p>제품의 속성과 수준을 정의하고 다항 로지트 모델을 사용하여 시장 점유율을 예측합니다.</p>
        
        <div class="step" id="step1">
            <h2>1단계: 제품 카테고리 및 경쟁제품 정의</h2>
            <div class="form-group">
                <label for="productCategory">제품 카테고리:</label>
                <input type="text" id="productCategory" placeholder="예: 스마트폰, 음료수, 세탁기 등">
            </div>
            <div class="form-group">
                <label for="numProducts">경쟁자 수 결정 (본인 신제품 포함):</label>
                <input type="number" id="numProducts" min="2" max="10" value="3">
                <button onclick="setupProducts()">경쟁제품 수 설정</button>
            </div>
            
            <div id="productSetup" class="hide">
                <div class="form-group">
                    <label for="myProductName">본인 신제품 이름:</label>
                    <input type="text" id="myProductName" placeholder="본인 제품의 이름을 입력하세요">
                </div>
                <div id="competitorNames"></div>
                <div class="form-group">
                    <label for="numAttributes">이 시장에서 중요한 속성은 몇가지인가요? (4~8개):</label>
                    <input type="number" id="numAttributes" min="4" max="8" value="4">
                    <button onclick="setupAttributes()">속성 설정</button>
                </div>
            </div>
            
            <div id="attributeSetup" class="hide"></div>
            
            <div id="productDetails" class="hide"></div>
            
            <div class="form-group hide" id="populationGroup">
                <h3>3단계: 경쟁제품별 세부 사항 입력 완료</h3>
                <label for="population">잠재고객 수 (명):</label>
                <input type="number" id="population" min="1" value="5000">
                <button onclick="calculateUtilities()" id="calculateBtn">AI로 유틸리티 추정 및 계산하기</button>
            </div>
        </div>
        
        <div class="results" id="resultsSection">
            <h2>4단계: 분석 결과</h2>
            
            <h3>🔸 결과1: 경쟁제품 X 속성별 유틸리티</h3>
            <div id="utilityResults"></div>
            
            <h3>🔸 결과2: 경쟁제품별 시장점유율(추정)</h3>
            <div class="charts-row">
                <div class="chart-column" style="flex: 1;">
                    <div class="chart-title">시장 점유율(원 그래프)</div>
                    <div class="pie-chart-container" style="height: 400px; margin-bottom: 40px;">
                        <canvas id="marketSharePieChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="marketShareResults" style="display: none;"></div>
            
            <h3 style="margin-top: 80px;">🔸 결과3: 제품별 유틸리티합, 선택확률, 예상인구</h3>
            <div id="summaryResults"></div>
            
            <h3 style="margin-top: 80px;">🔁 결과4: 시뮬레이션</h3>
            <div class="simulation-container">
                <h4>내 제품 속성 변경 시뮬레이션</h4>
                <p>내 제품의 속성을 조정하여 시장 점유율 변화를 확인할 수 있습니다.</p>
                <div id="simulationControls" class="simulation-controls-vertical"></div>
                <button onclick="runSimulation()" class="btn-secondary">시뮬레이션 실행</button>
                
                <div style="margin-top: 30px;">
                    <div style="margin-bottom: 100px;">
                        <div class="chart-title">시뮬레이션 결과(원 그래프)</div>
                        <div class="pie-chart-container" style="height: 400px; margin: 0 auto 40px auto; max-width: 600px;">
                            <canvas id="simulationPieChart"></canvas>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 80px; margin-top: 300px;">
                        <div class="chart-title">시뮬레이션 결과 - 시장 점유율 변화</div>
                        <div id="simulationResults" style="margin-top: 20px;"></div>
                    </div>
                </div>
            </div>
            
            <div>
                <button onclick="resetSimulation()" class="btn-reset">새로운 시뮬레이션</button>
                <button onclick="adjustProduct()" class="btn-secondary">제품 속성 조정</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let products = [];
        let attributes = [];
        let utilities = {};
        let marketSharePieChart = null;
        let simulationPieChart = null;
        let productCategory = '';
        
        // 제품 설정
        function setupProducts() {
            const numProducts = parseInt(document.getElementById('numProducts').value);
            if (numProducts < 2 || numProducts > 10) {
                alert('제품 수는 2에서 10 사이여야 합니다.');
                return;
            }
            
            productCategory = document.getElementById('productCategory').value;
            if (!productCategory) {
                alert('제품 카테고리를 입력해주세요.');
                return;
            }
            
            products = [];
            for (let i = 0; i < numProducts; i++) {
                products.push({
                    id: i,
                    name: i === 0 ? '신제품' : `기존 제품 ${String.fromCharCode(65 + i - 1)}`,
                    attributes: {}
                });
            }
            
            document.getElementById('productSetup').classList.remove('hide');
            
            // 경쟁자 이름 입력 필드 생성
            const competitorNamesDiv = document.getElementById('competitorNames');
            competitorNamesDiv.innerHTML = '';
            
            // 첫번째 제품(신제품)은 별도 입력 필드가 있으므로 1부터 시작
            for (let i = 1; i < numProducts; i++) {
                const competitorGroup = document.createElement('div');
                competitorGroup.className = 'form-group';
                
                const competitorLabel = document.createElement('label');
                competitorLabel.textContent = `경쟁 제품 ${i} 이름:`;
                
                const competitorInput = document.createElement('input');
                competitorInput.type = 'text';
                competitorInput.id = `competitorName_${i}`;
                competitorInput.placeholder = `경쟁 제품 ${i}의 이름을 입력하세요`;
                
                competitorGroup.appendChild(competitorLabel);
                competitorGroup.appendChild(competitorInput);
                competitorNamesDiv.appendChild(competitorGroup);
            }
        }
        
        // 속성 설정
        function setupAttributes() {
            const numAttributes = parseInt(document.getElementById('numAttributes').value);
            if (numAttributes < 4 || numAttributes > 8) {
                alert('속성 수는 4에서 8 사이여야 합니다.');
                return;
            }
            
            // 제품 이름 업데이트
            const myProductName = document.getElementById('myProductName').value;
            if (!myProductName) {
                alert('본인 신제품 이름을 입력해주세요.');
                return;
            }
            
            // 첫번째 제품은 본인 제품
            products[0].name = myProductName;
            
            // 경쟁 제품 이름 업데이트
            for (let i = 1; i < products.length; i++) {
                const competitorName = document.getElementById(`competitorName_${i}`).value;
                if (competitorName) {
                    products[i].name = competitorName;
                }
            }
            
            attributes = [];
            const attributeSetup = document.getElementById('attributeSetup');
            attributeSetup.innerHTML = '';
            attributeSetup.classList.remove('hide');
            
            const attributeTitle = document.createElement('h3');
            attributeTitle.textContent = '2단계: 속성의 수 결정 (4~8개) 및 수준 정의 (2~4개)';
            attributeSetup.appendChild(attributeTitle);
            
            // 안내 메시지 추가
            const attributeGuide = document.createElement('div');
            attributeGuide.className = 'guide-message';
            attributeGuide.style.backgroundColor = '#f8f9fa';
            attributeGuide.style.padding = '10px';
            attributeGuide.style.borderRadius = '5px';
            attributeGuide.style.marginBottom = '15px';
            attributeGuide.style.borderLeft = '4px solid var(--primary-color)';
            attributeGuide.innerHTML = '<strong>안내:</strong> 각 속성은 연구하고자 하는 제품의 특성에 맞게 직접 기입하세요. 기본으로 제공된 속성명은 예시일 뿐입니다.';
            attributeSetup.appendChild(attributeGuide);
            
            const attributeNames = ['품질 (예시)', '디자인 (예시)', '가격 (예시)', '기능 (예시)', '용량 (예시)'];
            const scaleTypes = ['비율척도', '명목척도'];
            
            for (let i = 0; i < numAttributes; i++) {
                const attributeContainer = document.createElement('div');
                attributeContainer.className = 'attribute-container';
                
                const nameLabel = document.createElement('label');
                nameLabel.textContent = `속성 ${i + 1} 이름:`;
                
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.id = `attributeName${i}`;
                nameInput.value = i < attributeNames.length ? attributeNames[i] : '';
                
                const scaleLabel = document.createElement('label');
                scaleLabel.textContent = '척도 유형:';
                
                const scaleSelect = document.createElement('select');
                scaleSelect.id = `attributeScale${i}`;
                
                scaleTypes.forEach(scale => {
                    const option = document.createElement('option');
                    option.value = scale;
                    option.textContent = scale;
                    scaleSelect.appendChild(option);
                });
                
                const levelCountLabel = document.createElement('label');
                levelCountLabel.textContent = '수준 개수 (2~4개):';
                
                const levelCountInput = document.createElement('input');
                levelCountInput.type = 'number';
                levelCountInput.id = `levelCount${i}`;
                levelCountInput.min = '2';
                levelCountInput.max = '4';
                levelCountInput.value = '3';
                
                const levelContainer = document.createElement('div');
                levelContainer.id = `levelContainer${i}`;
                
                const setupLevelsBtn = document.createElement('button');
                setupLevelsBtn.textContent = '수준 설정';
                setupLevelsBtn.onclick = function() {
                    setupLevels(i);
                };
                
                attributeContainer.appendChild(nameLabel);
                attributeContainer.appendChild(nameInput);
                attributeContainer.appendChild(document.createElement('br'));
                attributeContainer.appendChild(scaleLabel);
                attributeContainer.appendChild(scaleSelect);
                attributeContainer.appendChild(document.createElement('br'));
                attributeContainer.appendChild(levelCountLabel);
                attributeContainer.appendChild(levelCountInput);
                attributeContainer.appendChild(setupLevelsBtn);
                attributeContainer.appendChild(levelContainer);
                
                attributeSetup.appendChild(attributeContainer);
            }
            
            // 모든 속성의 수준 확인 메시지
            const infoMsg = document.createElement('div');
            infoMsg.style.backgroundColor = 'lightyellow';
            infoMsg.style.padding = '10px';
            infoMsg.style.marginTop = '20px';
            infoMsg.style.borderRadius = '5px';
            infoMsg.innerHTML = `
                <p><strong>속성 별 수준 설정 안내:</strong></p>
                <ol>
                    <li>각 속성별로 "수준 설정" 버튼을 클릭하여 수준을 정의해주세요.</li>
                    <li>수준은 낮은 수준부터 높은 수준 순으로 입력하는 것이 좋습니다.</li>
                    <li>예: 가격은 낮은 가격부터 높은 가격 순으로, 품질은 낮은 품질부터 높은 품질 순으로.</li>
                    <li>모든 속성의 수준을 설정한 후 아래 버튼을 클릭하세요.</li>
                    <li>비율척도는 '100점만점에 (__) 점' 형식으로 기입해주세요. (예: '100점만점에 75점')</li>
                    <li>명목척도는 항목의 이름을 직접 기입해주세요. (예: '기본형', '프리미엄형')</li>
                    <li>가격 속성은 직접 가격을 기입해주세요. (예: '3000원', '5000원')</li>
                </ol>
            `;
            attributeSetup.appendChild(infoMsg);
            
            const setupProductsBtn = document.createElement('button');
            setupProductsBtn.textContent = '속성 확정 후 제품 세부사항 입력';
            setupProductsBtn.style.marginTop = '15px';
            setupProductsBtn.onclick = function() {
                finalizeAttributes();
            };
            
            attributeSetup.appendChild(setupProductsBtn);
        }
        
        // 수준 설정
        function setupLevels(attributeIndex) {
            const levelCount = parseInt(document.getElementById(`levelCount${attributeIndex}`).value);
            if (levelCount < 2 || levelCount > 4) {
                alert('수준 개수는 2에서 4 사이여야 합니다.');
                return;
            }
            
            const levelContainer = document.getElementById(`levelContainer${attributeIndex}`);
            levelContainer.innerHTML = '';
            
            const attributeName = document.getElementById(`attributeName${attributeIndex}`).value;
            const scale = document.getElementById(`attributeScale${attributeIndex}`).value;
            
            // 속성별 자세한 수준 설명과 예시 제공
            const attributeExamples = {
                '가격': {
                    levels: ['3000원', '5000원', '7000원', '9000원', '12000원'],
                    description: '제품 가격을 의미합니다. 일반적으로 가격이 낮을수록 소비자 선호도가 높아집니다.'
                },
                '품질': {
                    levels: ['하', '중', '상', '최상', '프리미엄'],
                    description: '제품의 품질 수준을 의미합니다. 일반적으로 품질이 높을수록 소비자 선호도가 높아집니다.'
                },
                '디자인': {
                    levels: ['심플', '모던', '클래식', '유니크', '혁신적'],
                    description: '제품의 디자인 스타일을 의미합니다. 목표 시장에 따라 선호되는 디자인이 다를 수 있습니다.'
                },
                '브랜드': {
                    levels: ['신제품', '인기브랜드', '글로벌브랜드', '프리미엄브랜드', '럭셔리브랜드'],
                    description: '제품의, 브랜드 인지도 또는 브랜드 가치를 의미합니다.'
                },
                '기능': {
                    levels: ['기본형', '중급형', '고급형', '프리미엄형', '최고급형'],
                    description: '제품이 제공하는 기능의 수준을 의미합니다.'
                }
            };
            
            // 기본 예시 값
            const defaultExamples = ['수준 1', '수준 2', '수준 3', '수준 4', '수준 5'];
            
            // 속성에 대한 설명 추가
            const attributeDescription = document.createElement('p');
            attributeDescription.className = 'attribute-description';
            attributeDescription.style.marginBottom = '15px';
            attributeDescription.style.fontStyle = 'italic';
            
            if (attributeExamples[attributeName]) {
                attributeDescription.textContent = attributeExamples[attributeName].description;
            } else {
                attributeDescription.textContent = `${attributeName}의 서로 다른 수준을 정의해주세요.`;
            }
            
            levelContainer.appendChild(attributeDescription);
            
            // 수준 정의 헤더
            const levelHeader = document.createElement('h4');
            levelHeader.textContent = `${attributeName}의 수준 정의 (낮은 수준 → 높은 수준 순으로 입력):`;
            levelContainer.appendChild(levelHeader);
            
            // 수준 정의 입력 필드
            for (let i = 0; i < levelCount; i++) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-container';
                
                const levelLabel = document.createElement('label');
                levelLabel.textContent = `수준 ${i + 1}:`;
                
                const levelInput = document.createElement('input');
                levelInput.type = 'text';
                levelInput.id = `level_${attributeIndex}_${i}`;
                levelInput.style.width = '250px';
                
                // 척도 유형에 따라 다른 예시 및 placeholder 제공
                if (attributeName.includes('가격')) {
                    // 가격 속성은 직접 가격 입력
                    levelInput.placeholder = '직접 가격을 입력하세요 (예: 3000원)';
                    if (attributeExamples[attributeName] && i < attributeExamples[attributeName].levels.length) {
                        levelInput.value = attributeExamples[attributeName].levels[i];
                    } else {
                        levelInput.value = `${(i+1) * 1000}원`;
                    }
                } else if (scale === '비율척도') {
                    // 비율척도는 100점 만점 형식
                    levelInput.placeholder = '100점만점에 (__) 점';
                    const points = (i + 1) * 20; // 20, 40, 60, 80, 100 등으로 분포
                    levelInput.value = `100점만점에 ${points}점`;
                } else { // 명목척도
                    // 명목척도는 직접 입력
                    levelInput.placeholder = '직접 입력 (예: 기본형, 프리미엄 등)';
                    if (attributeExamples[attributeName] && i < attributeExamples[attributeName].levels.length) {
                        levelInput.value = attributeExamples[attributeName].levels[i];
                    } else {
                        levelInput.value = defaultExamples[i];
                    }
                }
                
                // 예시 표시
                const levelExample = document.createElement('span');
                levelExample.style.marginLeft = '10px';
                levelExample.style.color = '#666';
                levelExample.style.fontSize = '0.9em';
                
                if (i === 0) levelExample.textContent = '(가장 낮은 수준)';
                if (i === levelCount - 1) levelExample.textContent = '(가장 높은 수준)';
                
                // 유틸리티 값은 hidden input으로 변경 (AI가 자동 계산함)
                const utilityInput = document.createElement('input');
                utilityInput.type = 'hidden';
                utilityInput.id = `utility_${attributeIndex}_${i}`;
                utilityInput.value = '0'; // 초기값, 나중에 AI가 계산
                
                levelDiv.appendChild(levelLabel);
                levelDiv.appendChild(levelInput);
                levelDiv.appendChild(levelExample);
                levelDiv.appendChild(utilityInput);
                
                levelContainer.appendChild(levelDiv);
            }
        }
        
        // 속성 확정
        function finalizeAttributes() {
            attributes = [];
            
            for (let i = 0; i < parseInt(document.getElementById('numAttributes').value); i++) {
                const name = document.getElementById(`attributeName${i}`).value;
                const scale = document.getElementById(`attributeScale${i}`).value;
                const levelCount = parseInt(document.getElementById(`levelCount${i}`).value);
                
                const levels = [];
                
                for (let j = 0; j < levelCount; j++) {
                    const levelElement = document.getElementById(`level_${i}_${j}`);
                    
                    if (!levelElement) {
                        alert(`${name} 속성의 수준을 먼저 설정해주세요.`);
                        return;
                    }
                    
                    const level = levelElement.value;
                    levels.push(level);
                }
                
                attributes.push({
                    id: i,
                    name: name,
                    scale: scale,
                    levels: levels
                });
            }
            
            setupProductDetails();
        }
        
        // 제품 세부사항 설정
        function setupProductDetails() {
            const productDetails = document.getElementById('productDetails');
            productDetails.innerHTML = '';
            productDetails.classList.remove('hide');
            
            const detailTitle = document.createElement('h3');
            detailTitle.textContent = '3단계: 경쟁제품별 세부 사항 입력';
            productDetails.appendChild(detailTitle);
            
            products.forEach(product => {
                const productContainer = document.createElement('div');
                productContainer.className = 'product-container';
                
                const productTitle = document.createElement('h3');
                productTitle.textContent = product.name;
                
                productContainer.appendChild(productTitle);
                
                // 제품명 표시 (이미 입력받았으므로 수정 불가)
                const nameGroup = document.createElement('div');
                nameGroup.className = 'form-group';
                
                const nameLabel = document.createElement('label');
                nameLabel.textContent = '제품명:';
                
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.id = `productName_${product.id}`;
                nameInput.value = product.name;
                nameInput.readOnly = true;
                
                nameGroup.appendChild(nameLabel);
                nameGroup.appendChild(nameInput);
                productContainer.appendChild(nameGroup);
                
                // 각 속성별 레벨 선택 (가격은 마지막으로)
                const sortedProductAttributes = [...attributes].sort((a, b) => {
                    if (a.name.includes('가격')) return 1;
                    if (b.name.includes('가격')) return -1;
                    return 0;
                });
                
                sortedProductAttributes.forEach(attribute => {
                    const attrGroup = document.createElement('div');
                    attrGroup.className = 'form-group';
                    
                    const attrLabel = document.createElement('label');
                    attrLabel.textContent = `${attribute.name} (${attribute.scale}):`;
                    
                    const attrSelect = document.createElement('select');
                    attrSelect.id = `product_${product.id}_attr_${attribute.id}`;
                    
                    attribute.levels.forEach(level => {
                        const option = document.createElement('option');
                        option.value = level;
                        option.textContent = level;
                        attrSelect.appendChild(option);
                    });
                    
                    attrGroup.appendChild(attrLabel);
                    attrGroup.appendChild(attrSelect);
                    productContainer.appendChild(attrGroup);
                });
                
                productDetails.appendChild(productContainer);
            });
            
            document.getElementById('populationGroup').classList.remove('hide');
        }
        
        // AI를 사용하여 유틸리티 추정
        function estimateUtilities() {
            // 속성 별로 유틸리티 추정 로직
            attributes.forEach(attribute => {
                const levelUtilities = {};
                
                // 속성 타입에 따라 유틸리티 값 추정
                if (attribute.name.includes('가격')) {
                    // 가격: 낮을수록 높은 유틸리티 (음수 유틸리티, 가격이 높을수록 유틸리티가 낮음)
                    attribute.levels.forEach((level, index) => {
                        // 가격에서 숫자만 추출
                        const priceMatch = level.match(/\d+/);
                        if (priceMatch) {
                            const price = parseInt(priceMatch[0]);
                            // 가격이 높을수록 더 낮은 유틸리티
                            const normalizedPrice = price / 1000; // 정규화
                            levelUtilities[level] = -0.2 * normalizedPrice;
                        } else {
                            // 숫자 추출 불가능한 경우 순서에 따라 유틸리티 부여
                            levelUtilities[level] = -0.2 * (index + 1);
                        }
                    });
                } else if (attribute.name.includes('품질') || attribute.name.includes('성능')) {
                    // 품질/성능: 높을수록 높은 유틸리티 (양수 유틸리티)
                    const qualityRank = {
                        '하': 0.1,
                        '중': 0.3,
                        '상': 0.5,
                        '최상': 0.7,
                        '프리미엄': 0.9
                    };
                    
                    attribute.levels.forEach((level, index) => {
                        if (qualityRank[level] !== undefined) {
                            levelUtilities[level] = qualityRank[level];
                        } else {
                            // 일반적으로 뒤에 있는 수준이 더 좋은 품질
                            levelUtilities[level] = 0.2 * (index + 1);
                        }
                    });
                } else if (attribute.name.includes('브랜드')) {
                    // 브랜드: 브랜드 가치에 따른 유틸리티
                    const brandRank = {
                        '신제품': 0.2,
                        '인기브랜드': 0.4,
                        '글로벌브랜드': 0.6,
                        '프리미엄브랜드': 0.8,
                        '럭셔리브랜드': 1.0
                    };
                    
                    attribute.levels.forEach((level, index) => {
                        if (brandRank[level] !== undefined) {
                            levelUtilities[level] = brandRank[level];
                        } else {
                            // 브랜드는 중간 정도의 유틸리티
                            levelUtilities[level] = 0.3 + (0.1 * index);
                        }
                    });
                } else {
                    // 기타 속성: 순서대로 점차 증가하는 유틸리티
                    attribute.levels.forEach((level, index) => {
                        // 일반적으로 뒤에 있는 수준이 더 선호됨
                        levelUtilities[level] = 0.25 * (index + 1);
                    });
                }
                
                attribute.utilities = levelUtilities;
            });
            
            // 각 속성 별로 유틸리티 계산
            products.forEach(product => {
                product.name = document.getElementById(`productName_${product.id}`).value;
                product.attributes = {};
                product.utility = 0;
                
                attributes.forEach(attribute => {
                    const levelElement = document.getElementById(`product_${product.id}_attr_${attribute.id}`);
                    const level = levelElement.value;
                    
                    product.attributes[attribute.name] = level;
                    product.utility += attribute.utilities[level];
                });
            });
            
            return true;
        }
        
        // 유틸리티 계산
        function calculateUtilities() {
            // AI로 유틸리티 추정
            if (estimateUtilities()) {
                // 결과 표시
                displayResults();
                
                // 원 그래프 초기화
                initPieChart();
            } else {
                alert('유틸리티 추정 중 오류가 발생했습니다.');
            }
        }
        
        // 원 그래프 초기화
        function initPieChart() {
            // 기존 차트 제거
            if (marketSharePieChart) {
                marketSharePieChart.destroy();
            }
            if (simulationPieChart) {
                simulationPieChart.destroy();
            }
            
            // 제품별 색상 설정 - 모던한 색상 팔레트로 변경 (더 진한 색상)
            const backgroundColors = [
                'rgba(91, 127, 255, 0.9)', // Soft blue
                'rgba(54, 209, 220, 0.9)', // Turquoise
                'rgba(92, 84, 164, 0.9)',  // Medium purple
                'rgba(255, 118, 118, 0.9)', // Coral pink
                'rgba(76, 181, 142, 0.9)', // Mint green
                'rgba(156, 136, 255, 0.9)', // Light purple
                'rgba(86, 204, 242, 0.9)', // Sky blue
                'rgba(255, 179, 71, 0.9)', // Soft orange
                'rgba(235, 107, 170, 0.9)', // Soft pink
                'rgba(68, 157, 209, 0.9)', // Blue
            ];
            
            // 제품 이름과 선택 확률 데이터 추출
            const labels = products.map(product => product.name);
            const data = products.map(product => product.probability * 100);
            
            // Chart.js plugin configuration for adding percentage labels
            Chart.register({
                id: 'percentageLabels',
                afterDraw: function(chart) {
                    if (chart.config.type !== 'pie') return;
                    
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    const data = chart.data.datasets[0].data;
                    const labels = chart.data.labels;
                    const total = data.reduce((a, b) => a + b, 0);
                    
                    // Skip if no chartArea
                    if (!chartArea) return;
                    
                    // Pie chart center point
                    const centerX = (chartArea.left + chartArea.right) / 2;
                    const centerY = (chartArea.top + chartArea.bottom) / 2;
                    const radius = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top) / 2;
                    
                    // Create labels
                    let currentAngle = -0.5 * Math.PI; // Start from top
                    
                    for (let i = 0; i < data.length; i++) {
                        const sliceAngle = 2 * Math.PI * data[i] / total;
                        const angle = currentAngle + sliceAngle / 2;
                        
                        // Calculate position - move labels closer to edge for better visibility
                        const labelRadius = radius * 0.75;
                        
                        const x = centerX + Math.cos(angle) * labelRadius;
                        const y = centerY + Math.sin(angle) * labelRadius;
                        
                        const percentageText = `${data[i].toFixed(1)}%`;
                        
                        // Only draw label if slice is visible enough (> 3%)
                        if (data[i] / total > 0.03) {
                            // First draw a strong black outline/stroke around text
                            ctx.save();
                            ctx.font = 'bold 28px Arial'; // Even larger font
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // Draw text stroke (outline)
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 6;
                            ctx.lineJoin = 'round'; // Rounded joins for smoother outline
                            ctx.strokeText(percentageText, x, y);
                            
                            // Draw text fill (white for maximum contrast)
                            ctx.fillStyle = 'white';
                            ctx.fillText(percentageText, x, y);
                            
                            ctx.restore();
                        }
                        
                        currentAngle += sliceAngle;
                    }
                }
            });
            
            // 시장 점유율 원 그래프 생성
            const pieCtx = document.getElementById('marketSharePieChart').getContext('2d');
            marketSharePieChart = new Chart(pieCtx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors.slice(0, products.length),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.formattedValue || '';
                                    return `${label}: ${value}%`;
                                }
                            }
                        }
                    }
                }
            });
            
            // 시뮬레이션 원 그래프 초기화 (데이터는 시뮬레이션 시 업데이트)
            const simPieCtx = document.getElementById('simulationPieChart').getContext('2d');
            simulationPieChart = new Chart(simPieCtx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors.slice(0, products.length),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.formattedValue || '';
                                    return `${label}: ${value}%`;
                                }
                            }
                        }
                    }
                },
                // Uses the same plugin registered earlier
                plugins: ['percentageLabels']
            });
            
            // 시뮬레이션 컨트롤 설정
            setupSimulationControls();
        }
        
        // 시뮬레이션 제어 설정
        function setupSimulationControls() {
            const simulationControls = document.getElementById('simulationControls');
            simulationControls.innerHTML = '';
            
            // 속성을 정렬하여 가격을 마지막으로
            const sortedSimAttributes = [...attributes].sort((a, b) => {
                if (a.name.includes('가격')) return 1;
                if (b.name.includes('가격')) return -1;
                return 0;
            });
            
            // 본인 제품(첫 번째 제품)의 각 속성별 슬라이더 생성
            sortedSimAttributes.forEach(attribute => {
                const level = products[0].attributes[attribute.name];
                const utility = attribute.utilities[level];
                
                const sliderContainer = document.createElement('div');
                sliderContainer.className = 'slider-container';
                
                const sliderLabel = document.createElement('div');
                sliderLabel.className = 'slider-label';
                
                const sliderName = document.createElement('span');
                sliderName.textContent = `${attribute.name} 조정`;
                
                const sliderValue = document.createElement('span');
                sliderValue.id = `slider_value_${attribute.id}`;
                sliderValue.textContent = '0%';
                
                sliderLabel.appendChild(sliderName);
                sliderLabel.appendChild(sliderValue);
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'simulation-slider';
                slider.id = `attr_slider_${attribute.id}`;
                slider.min = '-50';
                slider.max = '50';
                slider.value = '0';
                slider.step = '5';
                
                slider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    document.getElementById(`slider_value_${attribute.id}`).textContent = `${value > 0 ? '+' : ''}${value}%`;
                });
                
                sliderContainer.appendChild(sliderLabel);
                sliderContainer.appendChild(slider);
                
                simulationControls.appendChild(sliderContainer);
            });
        }
        
        // 시뮬레이션 실행
        function runSimulation() {
            // 원본 유틸리티 값을 복사하여 시뮬레이션
            const originalProducts = JSON.parse(JSON.stringify(products));
            const myProduct = products[0]; // 첫 번째 제품이 본인 제품
            
            // 각 속성별 슬라이더 값에 따라 유틸리티 조정
            attributes.forEach(attribute => {
                const slider = document.getElementById(`attr_slider_${attribute.id}`);
                const adjustmentPercent = parseInt(slider.value) / 100;
                
                const level = myProduct.attributes[attribute.name];
                const originalUtility = attribute.utilities[level];
                
                // 조정된 유틸리티 계산
                const adjustedUtility = originalUtility * (1 + adjustmentPercent);
                
                // 조정된 유틸리티 적용
                myProduct.utility += (adjustedUtility - originalUtility);
            });
            
            // 시뮬레이션 결과 계산 (다항 로지트 모델)
            const expUtilities = products.map(product => Math.exp(product.utility));
            const sumExpUtilities = expUtilities.reduce((a, b) => a + b, 0);
            
            products.forEach((product, index) => {
                product.simProbability = expUtilities[index] / sumExpUtilities;
            });
            
            // 시뮬레이션 결과 표시
            displaySimulationResults();
            
            // 원래 유틸리티 값으로 복원
            products = originalProducts;
        }
        
        // 시뮬레이션 결과 표시
        function displaySimulationResults() {
            const simulationResults = document.getElementById('simulationResults');
            simulationResults.innerHTML = '';
            
            // 원 그래프 데이터 업데이트
            const labels = products.map(product => product.name);
            const data = products.map(product => (product.simProbability || product.probability) * 100);
            
            simulationPieChart.data.labels = labels;
            simulationPieChart.data.datasets[0].data = data;
            simulationPieChart.update();
            
            // 시뮬레이션 결과 막대 그래프 추가
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            
            const barChart = document.createElement('div');
            barChart.className = 'bar-chart';
            
            // 제품별 시장 점유율 바 생성
            products.forEach((product, index) => {
                const barGroup = document.createElement('div');
                barGroup.className = 'bar-group';
                
                const barLabel = document.createElement('div');
                barLabel.className = 'bar-label';
                barLabel.textContent = product.name;
                barGroup.appendChild(barLabel);
                
                const barWrapper = document.createElement('div');
                barWrapper.className = 'bar-wrapper';
                
                const newProb = product.simProbability || product.probability;
                const sharePercentage = newProb * 100;
                
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.width = `${sharePercentage}%`;
                
                const barColors = [
                    'var(--chart-color-1)',
                    'var(--chart-color-2)',
                    'var(--chart-color-3)',
                    'var(--chart-color-4)',
                    'var(--chart-color-5)'
                ];
                bar.style.backgroundColor = barColors[index % barColors.length];
                
                barWrapper.appendChild(bar);
                
                const barValue = document.createElement('div');
                barValue.className = 'bar-value';
                barValue.textContent = `${sharePercentage.toFixed(1)}%`;
                bar.appendChild(barValue);
                
                barGroup.appendChild(barWrapper);
                barChart.appendChild(barGroup);
            });
            
            chartContainer.appendChild(barChart);
            simulationResults.appendChild(chartContainer);
            
            // 테이블 결과 표시
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
            table.style.margin = '40px auto';
            table.style.maxWidth = '800px';
            
            // 테이블 헤더
            const headerRow = document.createElement('tr');
            const headerCells = ['제품명', '원래 점유율', '조정 후 점유율', '변화'];
            
            headerCells.forEach(cell => {
                const th = document.createElement('th');
                th.textContent = cell;
                th.style.backgroundColor = 'var(--primary-color)';
                th.style.color = 'white';
                th.style.padding = '12px';
                th.style.textAlign = 'center';
                headerRow.appendChild(th);
            });
            
            table.appendChild(headerRow);
            
            // 각 제품별 시뮬레이션 결과
            products.forEach((product, index) => {
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.textContent = product.name;
                nameCell.style.fontWeight = 'bold';
                nameCell.style.padding = '10px';
                nameCell.style.textAlign = 'center';
                
                const originalCell = document.createElement('td');
                originalCell.textContent = `${(product.probability * 100).toFixed(1)}%`;
                originalCell.style.padding = '10px';
                originalCell.style.textAlign = 'center';
                
                const newCell = document.createElement('td');
                const newProb = product.simProbability || product.probability;
                newCell.textContent = `${(newProb * 100).toFixed(1)}%`;
                newCell.style.fontWeight = 'bold';
                newCell.style.padding = '10px';
                newCell.style.textAlign = 'center';
                
                const changeCell = document.createElement('td');
                const change = ((newProb - product.probability) * 100).toFixed(1);
                changeCell.textContent = change > 0 ? `+${change}%` : `${change}%`;
                changeCell.style.padding = '10px';
                changeCell.style.textAlign = 'center';
                changeCell.style.fontWeight = 'bold';
                
                // 변화에 따라 색상 적용
                if (parseFloat(change) > 0) {
                    changeCell.style.color = 'green';
                } else if (parseFloat(change) < 0) {
                    changeCell.style.color = 'red';
                }
                
                row.appendChild(nameCell);
                row.appendChild(originalCell);
                row.appendChild(newCell);
                row.appendChild(changeCell);
                
                // Add alternating row colors
                if (index % 2 === 1) {
                    row.style.backgroundColor = '#f8f9fa';
                }
                
                table.appendChild(row);
            });
            
            simulationResults.appendChild(table);
        }
        
        // 결과 표시
        function displayResults() {
            document.getElementById('resultsSection').style.display = 'block';
            
            // 유틸리티 테이블 생성
            const utilityResults = document.getElementById('utilityResults');
            utilityResults.innerHTML = '';
            
            // 각 제품별 유틸리티 테이블과 막대 그래프
            products.forEach((product, productIndex) => {
                const productTitle = document.createElement('h4');
                productTitle.textContent = product.name;
                utilityResults.appendChild(productTitle);
                
                // 막대 그래프 추가
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container product-chart';
                
                const chartTitle = document.createElement('div');
                chartTitle.className = 'chart-title';
                chartTitle.textContent = '속성별 유틸리티 시각화';
                chartContainer.appendChild(chartTitle);
                
                const barChart = document.createElement('div');
                barChart.className = 'bar-chart';
                
                // Add grid lines for better readability
                const barChartGrid = document.createElement('div');
                barChartGrid.className = 'bar-chart-grid';
                
                // 속성별 유틸리티 값과 색상
                const barColors = [
                    'var(--chart-color-1)',
                    'var(--chart-color-2)',
                    'var(--chart-color-3)',
                    'var(--chart-color-4)',
                    'var(--chart-color-5)'
                ];
                
                // 최대 유틸리티 값 찾기 (스케일링용)
                let maxUtilityAbs = 0;
                attributes.forEach(attribute => {
                    const level = product.attributes[attribute.name];
                    const utility = attribute.utilities[level];
                    maxUtilityAbs = Math.max(maxUtilityAbs, Math.abs(utility));
                });
                
                maxUtilityAbs = Math.max(maxUtilityAbs, 1); // 최소 스케일 설정
                
                // Create grid lines
                for (let i = 0; i <= 5; i++) {
                    const gridLine = document.createElement('div');
                    gridLine.className = 'grid-line';
                    gridLine.style.left = `${i * 20}%`;
                    barChartGrid.appendChild(gridLine);
                }
                
                barChart.appendChild(barChartGrid);
                
                // Create x-axis labels
                const xAxis = document.createElement('div');
                xAxis.className = 'bar-chart-x-axis';
                for (let i = 0; i <= 5; i++) {
                    const label = document.createElement('div');
                    label.textContent = `${i * 0.2}`;
                    xAxis.appendChild(label);
                }
                
                // 속성 배열 복사 및 재정렬 (가격 속성을 마지막으로)
                const sortedAttributes = [...attributes].sort((a, b) => {
                    if (a.name.includes('가격')) return 1;
                    if (b.name.includes('가격')) return -1;
                    return 0;
                });
                
                // 각 속성에 대한 바 생성
                sortedAttributes.forEach((attribute, index) => {
                    const level = product.attributes[attribute.name];
                    const utility = attribute.utilities[level];
                    
                    // Calculate percentage for display
                    const percentage = Math.abs(utility) / maxUtilityAbs * 100;
                    
                    const barGroup = document.createElement('div');
                    barGroup.className = 'bar-group';
                    
                    const barLabel = document.createElement('div');
                    barLabel.className = 'bar-label';
                    barLabel.textContent = attribute.name;
                    barGroup.appendChild(barLabel);
                    
                    const barWrapper = document.createElement('div');
                    barWrapper.className = 'bar-wrapper';
                    
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.width = `${percentage}%`;
                    
                    // Find the original index for coloring
                    const originalIndex = attributes.findIndex(attr => attr.name === attribute.name);
                    bar.style.backgroundColor = barColors[originalIndex % barColors.length];
                    
                    barWrapper.appendChild(bar);
                    
                    const barValue = document.createElement('div');
                    barValue.className = 'bar-value';
                    barValue.textContent = `${Math.round(percentage)}%`;
                    bar.appendChild(barValue);
                    
                    barGroup.appendChild(barWrapper);
                    barChart.appendChild(barGroup);
                });
                
                // 총 유틸리티 바는 제거 (요청에 따라)
                
                barChart.appendChild(xAxis);
                
                chartContainer.appendChild(barChart);
                utilityResults.appendChild(chartContainer);
                
                // 기존 테이블 추가
                const table = document.createElement('table');
                
                // 테이블 헤더
                const headerRow = document.createElement('tr');
                const headerCells = ['속성', '수준', '유틸리티'];
                headerCells.forEach(cell => {
                    const th = document.createElement('th');
                    th.textContent = cell;
                    headerRow.appendChild(th);
                });
                table.appendChild(headerRow);
                
                // 속성별 유틸리티
                let totalUtility = 0;
                
                // 같은 정렬 순서 사용 (가격을 마지막으로)
                sortedAttributes.forEach(attribute => {
                    const level = product.attributes[attribute.name];
                    const utility = attribute.utilities[level];
                    totalUtility += utility;
                    
                    const row = document.createElement('tr');
                    
                    const attrCell = document.createElement('td');
                    attrCell.textContent = attribute.name;
                    
                    const levelCell = document.createElement('td');
                    levelCell.textContent = level;
                    
                    const utilityCell = document.createElement('td');
                    utilityCell.textContent = utility > 0 ? `+${utility.toFixed(4)}` : utility.toFixed(4);
                    
                    row.appendChild(attrCell);
                    row.appendChild(levelCell);
                    row.appendChild(utilityCell);
                    
                    table.appendChild(row);
                });
                
                // 총 유틸리티 행은 제거 (요청에 따라)
                
                utilityResults.appendChild(table);
            });
            
            // 제품 요약 테이블 생성 (결과2에 표시될 테이블)
            const summaryTable = document.createElement('table');
            summaryTable.style.marginTop = '30px';
            summaryTable.style.width = '100%';
            summaryTable.style.borderCollapse = 'collapse';
            summaryTable.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
            
            // 테이블 헤더
            const headerRow = document.createElement('tr');
            const population = parseInt(document.getElementById('population').value);
            const headerCells = ['제품명', '유틸리티 합', '선택 확률', `예상 인원 (도시 인구 ${population.toLocaleString()}명 기준)`];
            
            headerCells.forEach(cell => {
                const th = document.createElement('th');
                th.textContent = cell;
                th.style.backgroundColor = 'var(--primary-color)';
                th.style.color = 'white';
                th.style.padding = '12px';
                th.style.textAlign = 'center';
                headerRow.appendChild(th);
            });
            
            summaryTable.appendChild(headerRow);
            
            // 다항 로지트 모델 계산
            const expUtilities = products.map(product => Math.exp(product.utility));
            const sumExpUtilities = expUtilities.reduce((a, b) => a + b, 0);
            
            products.forEach((product, index) => {
                const probability = expUtilities[index] / sumExpUtilities;
                const expectedPopulation = Math.round(probability * population);
                
                product.probability = probability;
                product.expectedPopulation = expectedPopulation;
                
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.textContent = product.name;
                nameCell.style.fontWeight = 'bold';
                nameCell.style.padding = '10px';
                nameCell.style.textAlign = 'center';
                
                const utilityCell = document.createElement('td');
                utilityCell.textContent = product.utility.toFixed(4);
                utilityCell.style.padding = '10px';
                utilityCell.style.textAlign = 'center';
                
                const probCell = document.createElement('td');
                probCell.textContent = `${(probability * 100).toFixed(1)}%`;
                probCell.style.fontWeight = 'bold';
                probCell.style.padding = '10px';
                probCell.style.textAlign = 'center';
                
                const popCell = document.createElement('td');
                popCell.textContent = `${expectedPopulation.toLocaleString()}명`;
                popCell.style.padding = '10px';
                popCell.style.textAlign = 'center';
                
                row.appendChild(nameCell);
                row.appendChild(utilityCell);
                row.appendChild(probCell);
                row.appendChild(popCell);
                
                // Add alternating row colors
                if (index % 2 === 1) {
                    row.style.backgroundColor = '#f8f9fa';
                }
                
                summaryTable.appendChild(row);
            });
            
            // 결과3 섹션에 요약 테이블 추가
            const summaryResults = document.getElementById('summaryResults');
            summaryResults.innerHTML = '';
            summaryResults.appendChild(summaryTable);
            
            // 시장 점유율 시각화 차트는 숨김 처리 (요청대로 제거)
            const marketShareResults = document.getElementById('marketShareResults');
            marketShareResults.innerHTML = '';
            
            // 위쪽으로 스크롤
            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
        }
        
        // 시뮬레이션 리셋
        function resetSimulation() {
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('productDetails').classList.add('hide');
            document.getElementById('attributeSetup').classList.add('hide');
            document.getElementById('productSetup').classList.add('hide');
            document.getElementById('populationGroup').classList.add('hide');
            
            document.getElementById('numProducts').value = 3;
            document.getElementById('numAttributes').value = 3;
            
            products = [];
            attributes = [];
            utilities = {};
        }
        
        // 제품 속성 조정
        function adjustProduct() {
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('productDetails').classList.remove('hide');
            document.getElementById('populationGroup').classList.remove('hide');
            document.getElementById('productDetails').scrollIntoView({ behavior: 'smooth' });
        }
        
        // 초기화
        function init() {
            // 한국어 폰트 추가
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css';
            document.head.appendChild(link);
            
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap';
            document.head.appendChild(fontLink);
        }
        
        // 페이지 로드 시 초기화
        window.onload = init;
    </script>
</body>
</html>